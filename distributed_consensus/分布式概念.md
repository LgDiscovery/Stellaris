## 第一阶段：理解核心思想（地基篇）

不要一上来就扎进 Redis、MySQL 的具体配置里。先花少量时间理解三个核心概念，这是所有分布式技术的基石：

1. **CAP 定理**：一个分布式系统无法同时满足以下三点，必须有所取舍：
   * **C**onsistency（一致性）：所有节点在同一时间看到的数据是一样的。
   * **A**vailability（可用性）：每次请求都能得到非错的响应，但不保证是最新数据。
   * **P**artition Tolerance（分区容错性）：系统在遇到网络分区（节点间无法通信）时仍然能够继续工作。
   * **通俗理解**：网络故障（P）无法避免，所以必须在 C 和 A 之间做选择。**CP系统**（如 ZooKeeper）保证一致性，宁可暂停服务；**AP系统**（如 Cassandra）保证可用性，先返回可能过期的数据。
2. **BASE 理论**：这是对 CAP 中 AP 方案的延伸，强调最终一致性，是互联网分布式系统的实践总结。
   * **BA**sically **A**vailable（基本可用）：系统出现故障时，允许损失部分可用性（如响应变慢、返回降级数据）。
   * **S**oft state（软状态）：允许系统中的数据存在中间状态，并且该状态不影响整体可用性。
   * **E**ventually consistent（最终一致）：经过一段时间后，所有数据副本会最终达到一致。
3. **一致性算法**：理解 **Paxos** 或 **Raft**。你不需要会实现，但要明白它们是**如何让多个节点就对某个值达成共识**的。Raft 比 Paxos 更易理解，建议从它入手。

## 拆解核心问题（框架篇）

所有分布式系统都在解决以下几个经典问题，把你的学习围绕它们展开：


| 核心问题         | 要解决什么？                     | 关键技术/方案举例                                    |
| ---------------- | -------------------------------- | ---------------------------------------------------- |
| **分布式共识**   | 多个节点如何就一个决定达成一致？ | Raft, Paxos, ZAB (ZooKeeper)                         |
| **数据分布**     | 海量数据如何分到多个机器上？     | **分库分表**、**一致性哈希** (Redis Cluster)         |
| **容错与高可用** | 如何避免单点故障？               | **主从复制** (MySQL, Redis)、**故障转移** (Sentinel) |
| **伸缩性**       | 如何平滑地扩缩容？               | 无状态设计、数据分片、服务发现                       |
| **分布式事务**   | 如何保证跨数据库的操作一致性？   | 2PC, 3PC, TCC, Saga, 消息队列                        |

## 第三阶段：攻克具体技术（实践篇）

有了上面的框架，再去看具体的技术，你就会恍然大悟：“原来它是用来解决这个问题的！

* **Redis 分布式**：
  * **主从复制 (Replication)**：解决**读高可用**和**数据备份**。主节点负责写，从节点负责读。这是**容错**方案。
  * **哨兵 (Sentinel)**：解决主节点的**自动故障转移**。哨兵集群监控主节点，主挂了能自动选一个新主出来。这是**高可用**方案。
  * **集群 (Cluster)**：解决**海量数据存储**和**高并发写**。将数据分片（sharding）到多个节点上，每个节点存储一部分数据。这是**伸缩性**方案，采用了类似一致性哈希的数据分片方式。
* **MySQL 分布式**：
  * **主从复制**：同 Redis，分担读压力、数据备份。
  * **分库分表**：解决**单机存储和性能瓶颈**。**水平分表**（按行切分）是最常见的方式，需要解决**路由问题**（数据在哪）、**扩容问题**（如何加机器）。
  * **中间件**：如 MyCat、ShardingSphere。它们帮你透明地管理分库分表、路由等复杂问题，对应用代码像操作单个数据库一样。

### 常见面试问题

1、讲一下你对CAP定理的理解

通俗回答：

CAP定理说的是：一个分布式系统最多只能同时满足以下三点中的两点：

c(一致性)：所有节点访问同一份最新的数据。

a(可用性)：每次请求都能等到响应，但不保证数据是最新的。

p(分区容错): 系统在遇到网络分区（节点间失联）时继续工作

核心在于 p是必然存在的（网络总可能出问题）,所以我们必须要在C和A之间做出抉择

CP:要一致性。当网络发生分区时，系统会暂停服务，保证所有节点的数据一致，直到网络恢复。

比如银行的转账系统，宁可暂时不能用，也绝对不能出现数据错乱。

> 代表：Zookeeper,Etcd

AP:要可用性。当网络发生分区时，系统继续提供服务，但可能返回旧数据。比如新闻网站、朋友全点赞，暂时看不到最新点赞没关系，但不能刷不出来。

> 代码：Eureka

2、什么是最终一致性？那些系统是最终一致性？

通俗回答：

最终一致性是AP系统追求的一种弱一致性模型。它不保证数据时刻一致，但经过一段‘同步’时间后，所有的副本的数据最终会达到一致状态。

比如：

你发了一条消息（写操作）-- 由于网咯延迟，有的群友可能稍等几秒才看到--但最终，所有在线的人都能看到这条消息（最终一致）

应用：

DNS系统：域名解析的变更需要时间转播到全球

社交功能：点赞数、评论数的更新

数据库主从同步：Mysql主从异步复制时，从库会有短暂延迟

**代表系统：** Redis 主从异步复制** 模式。

3、Raft算法为什么能达成共识

通话讲： raft通过一个强领袖模式和多数派机制来保证共识。

1、选一个老大（leader Election）:集群中只有一个领袖，所以指令都由它发出，避免了混乱。选举需要超过半数节点同意，确保同一时间最多只有一个合法老大。

2、老大指挥，大家记录（Log Replication）:客户端写请求必须发送给老大。老大自己不直接执行，而是先把指令记录下来，并让超过半数的小弟（Follow）也成功记录。

3、多数派同意才生效（Majority Commit）:一旦超过半数的小弟回复记好了、老大就认为这个指令可以正式生效，然后通知所有人执行。

为什么能达成共识？因为超过半数这个机制保证了：

* **任何两个多数派群体必然有重叠的节点**。这个重叠的节点确保了最新的日志条目绝不会丢失，一定会被后续的新领袖继承。这样，整个集群的状态就以领袖的日志为准，达成了一致。”
* **Redis 分布式**：

  * **主从复制 (Replication)**：解决**读高可用**和**数据备份**。主节点负责写，从节点负责读。这是**容错**方案。
  * **哨兵 (Sentinel)**：解决主节点的**自动故障转移**。哨兵集群监控主节点，主挂了能自动选一个新主出来。这是**高可用**方案。
  * **集群 (Cluster)**：解决**海量数据存储**和**高并发写**。将数据分片（sharding）到多个节点上，每个节点存储一部分数据。这是**伸缩性**方案，采用了类似一致性哈希的数据分片方式。
* **MySQL 分布式**：

  * **主从复制**：同 Redis，分担读压力、数据备份。
  * **分库分表**：解决**单机存储和性能瓶颈**。**水平分表**（按行切分）是最常见的方式，需要解决**路由问题**（数据在哪）、**扩容问题**（如何加机器）。
  * **中间件**：如 MyCat、ShardingSphere。它们帮你透明地管理分库分表、路由等复杂问题，对应用代码像操作单个数据库一样。
