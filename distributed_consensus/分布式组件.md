本次讲解将**按分布式架构的核心业务场景分类**（面试官提问也会遵循这个逻辑），覆盖**服务注册 / 配置、消息队列、分布式协调 / 锁、分布式存储、分布式事务**五大核心品类，每个品类下梳理**主流组件 + 核心参数（定位 / 协议 / 架构 / CAP）+ 同类别对比 + 面试高频考点**，同时补充组件间的关联与选型逻辑，所有内容贴合面试应答习惯，易记、易转述。

**核心原则**：分布式组件的设计本质是**在 CAP 理论、BASE 理论下做取舍**，面试中所有 “区别 / 选型” 问题，都可以围绕这个核心展开。

## 一、服务注册与配置中心（微服务核心，面试最高频）

**核心定位**：解决微服务架构中**服务发现（注册 / 寻址）** 和**配置统一管理（动态推送 / 热更新）** 问题，是微服务的 “大脑”。

**主流组件**：Nacos、Eureka、Consul、etcd、Zookeeper（ZK）

**补充**：ZK/etcd 原本是分布式协调组件，因具备键值存储 + 监听机制，被用作配置中心 / 简易注册中心；Nacos 是一站式组件，直接整合了 “注册中心 + 配置中心” 能力，也是目前国内企业的主流选型。

### 1. 核心组件参数表（面试核心记忆）


| 组件      | 开源方    | 核心定位                      | 核心协议 / 架构                                | CAP 选型 / 一致性                                      | 关键特性                                     | 典型生态 / 场景                         |
| --------- | --------- | ----------------------------- | ---------------------------------------------- | ------------------------------------------------------ | -------------------------------------------- | --------------------------------------- |
| **Nacos** | 阿里      | 一站式注册 + 配置中心         | 自定义协议（服务发现）Raft（配置中心 CP 模式） | **AP/CP 可切换**默认 AP（服务发现）支持 CP（配置中心） | 动态配置、服务健康检查、权重路由、一站式能力 | Spring Cloud Alibaba（国内主流）、Dubbo |
| Eureka    | Netflix   | 纯注册中心                    | 无强一致协议，HTTP 短轮询                      | 纯 AP                                                  | 自我保护机制、节点对等、轻量易用             | Spring Cloud Netflix（已停更）          |
| Consul    | HashiCorp | 注册 + 配置 + 服务网格        | Raft（一致性）gRPC/HTTP                        | 默 CP，可配 AP                                         | 原生健康检查、多数据中心、服务网格集成       | Spring Cloud Consul、K8s 生态           |
| etcd      | CoreOS    | 分布式键值存储（配置 / 注册） | Raft（强一致性）gRPC/HTTP                      | 纯 CP                                                  | 高可用、轻量、强一致性                       | K8s 核心（集群配置 / 服务发现）、云原生 |
| Zookeeper | Apache    | 分布式协调（兼职配置 / 注册） | ZAB 协议自定义 TCP 协议                        | 纯 CP                                                  | 树形节点、Watcher 监听、强一致性             | Hadoop/ZooKeeper 生态、Dubbo（早期）    |

### 2. 同类别核心对比（面试高频问答）

#### （1）Nacos vs Eureka+ZK（面试最常问：Nacos 为什么能替代两者）

Eureka 是**纯 AP 注册中心**，ZK 是**纯 CP 协调组件（兼职配置中心）**，而 Nacos 实现了 \*\*“Eureka 的 AP 注册中心能力 + ZK 的 CP 配置中心能力”\*\*，一站式解决问题，且做了优化：

* 比 Eureka：支持 CP 模式、配置中心能力、更完善的健康检查（Eureka 仅心跳，Nacos 支持 TCP/HTTP/ 脚本）；
* 比 ZK：支持 AP 模式（服务发现更可用）、动态配置热更新、轻量（ZK 需部署集群，Nacos 单节点即可用）；
* 核心优势：**AP/CP 可切换**—— 服务发现场景选 AP（高可用，适配微服务），配置中心场景选 CP（强一致，适配数据库密码 / 服务端口等核心配置）。

#### （2）etcd vs ZK（K8s 为什么选 etcd 而非 ZK 做核心存储）

两者都是纯 CP、强一致性，但 etcd 更适配**云原生 / K8s**：

* 协议：etcd 用 Raft（简单易懂、易实现、易维护），ZK 用 ZAB（专为 ZK 设计，复杂）；
* 接口：etcd 提供 HTTP/gRPC 接口，跨语言友好；ZK 是自定义 TCP 接口，需专用客户端；
* 轻量性：etcd 部署 / 运维更简单，资源占用低，适配 K8s 的容器化部署；
* 生态：etcd 是云原生 CNCF 基金会项目，与 K8s 深度整合。

#### （3）Consul vs Nacos

Consul 的优势在**多数据中心 + 服务网格**，适合跨国 / 跨地域的大型分布式架构；

Nacos 的优势在**一站式 + 国内生态 + 易用性**，适合国内中小微企业、基于 Spring Cloud Alibaba/Dubbo 的架构，部署和二次开发成本更低。

### 3. 面试高频提问 & 应答框架

* **问题 1**：微服务注册中心选型，Nacos、Eureka、Consul 怎么选？
  **答**：先看 CAP 需求（服务发现优先 AP），再看生态和场景：① 国内生态 + Spring Cloud Alibaba/Dubbo→Nacos；② 跨地域多数据中心→Consul；③ 轻量易用但无新需求→Eureka（注意提 Eureka 已停更）。
* **问题 2**：Nacos 的 AP/CP 怎么切换？分别适用于什么场景？
  **答**：通过配置`nacos.core.protocol.distro.compatibility.enable=true`切换；AP 用于**服务发现**（微服务寻址，高可用优先，允许短暂的节点不一致），CP 用于**配置中心**（核心配置如数据库密码，强一致优先，确保所有节点配置同步）。
* **问题 3**：ZK 做注册中心有什么缺点？
  **答**：① 纯 CP，Leader 选举期间集群不可用，影响服务注册 / 发现；② 节点是树形结构，设计复杂，不适合高频的服务注册（性能低）；③ 无原生的服务健康检查，需二次开发。

## 二、分布式消息队列（解耦 / 削峰 / 异步，面试高频）

**核心定位**：解决分布式架构中**系统解耦、流量削峰、异步通信、数据同步**问题，是分布式组件的 “通信枢纽”。

**主流组件**：Kafka、RocketMQ、RabbitMQ、Pulsar

**核心设计**：所有消息队列都基于**生产者 - 消费者模型**，核心差异在**协议、存储、副本机制、吞吐量、功能特性**，面试中常围绕 “吞吐量 / 可靠性 / 功能” 对比选型。

### 1. 核心组件参数表（面试核心记忆）


| 组件         | 开源方         | 核心定位                 | 核心协议 / 架构                           | 存储机制               | 核心特性                                  | 性能 / 吞吐量           | 典型场景                                 |
| ------------ | -------------- | ------------------------ | ----------------------------------------- | ---------------------- | ----------------------------------------- | ----------------------- | ---------------------------------------- |
| **Kafka**    | Apache         | 高吞吐、大数据消息队列   | TCP 自定义协议分区 + 副本架构             | 磁盘顺序写（持久化）   | 高吞吐、高可用、日志型存储、流处理集成    | 极高（10 万级 TPS）     | 大数据、日志采集、流处理（Flink/Spark）  |
| **RocketMQ** | 阿里（Apache） | 企业级消息队列           | TCP 自定义协议主从 + 集群                 | 磁盘顺序写             | 事务消息、延时消息、死信队列、高可靠性    | 高（万级～10 万级 TPS） | 电商、金融、企业级分布式架构（国内主流） |
| **RabbitMQ** | RabbitMQ 团队  | 轻量、功能丰富的消息队列 | AMQP（高级消息队列协议）主从              | 内存 + 磁盘            | 丰富的交换机 / 队列模式、轻量、跨语言友好 | 中（万级 TPS）          | 中小系统、轻量异步、即时通信             |
| Pulsar       | Apache         | 云原生多租户消息队列     | TCP 自定义协议分层架构（存储 / 计算分离） | 分层存储（BookKeeper） | 多租户、高吞吐、低延迟、流批一体          | 极高（媲美 Kafka）      | 云原生、多租户、流批一体架构             |

### 2. 同类别核心对比（面试高频问答）

#### （1）Kafka vs RocketMQ（国内企业最常选，面试必问）

两者都是高吞吐、持久化的消息队列，核心差异在**企业级功能**和**生态**：

* Kafka：优势在**高吞吐 + 大数据生态**，与 Flink/Spark 深度整合，适合日志采集、实时流处理；缺点是**企业级功能薄弱**（原生无事务消息、延时消息，需二次开发），运维复杂（副本 / 分区管理繁琐）。
* RocketMQ：优势在**企业级功能完善**（原生支持事务消息、延时消息、死信队列、消息回溯），运维简单，适配国内电商 / 金融场景；缺点是大数据生态不如 Kafka，但国内已做整合（如 Flink-RocketMQ 连接器）。
* **选型逻辑**：大数据 / 流处理→Kafka；电商 / 金融 / 企业级分布式架构→RocketMQ（国内主流）。

#### （2）RabbitMQ vs 前两者

RabbitMQ 的核心优势是**轻量 + 功能丰富 + 跨语言**，基于 AMQP 协议，支持直连 / 扇出 / 主题 / 头交换机，适合中小系统的轻量异步场景；

缺点是**吞吐量低**（基于 Erlang 开发，二次开发成本高）、**持久化性能一般**，不适合高吞吐的大数据 / 电商秒杀场景。

#### （3）Pulsar vs Kafka

Pulsar 是云原生时代的 “新一代 Kafka”，采用**计算 / 存储分离**的分层架构，比 Kafka 更易扩展、多租户支持更好、延迟更低；

目前的问题是**生态不如 Kafka 成熟**，国内企业落地较少，面试中了解即可。

### 3. 面试高频考点（Kafka 是重中之重）

#### （1）Kafka 核心原理（必问）

* 核心架构：**生产者→Broker（分区 + 副本）→消费者组**；
* 高吞吐原因：**磁盘顺序写**（比随机写快 100 倍）、**零拷贝**（减少数据拷贝次数）、**批量发送**、**分区并行处理**；
* 高可用机制：**副本 + ISR（同步副本集）**，Leader 负责读写，Follower 同步数据，ISR 内过半副本同步成功则消息提交，Leader 宕机后从 ISR 中选举新 Leader；
* 消费机制：消费者组内**一个分区只能被一个消费者消费**，保证消费顺序，消费者组之间可并行消费。

#### （2）RocketMQ 事务消息原理（必问，阿里系面试重点）

基于**两阶段提交 + 事务回查**实现：

1. 生产者发送**半消息**到 RocketMQ，半消息暂不被消费；
2. 生产者执行本地事务；
3. 若本地事务成功，发送**提交消息**，RocketMQ 推送消息给消费者；若失败，发送**回滚消息**，RocketMQ 删除半消息；
4. 若 RocketMQ 未收到提交 / 回滚消息，**定时回查**生产者的本地事务状态，根据状态处理半消息。

#### （3）消息队列的 “消息丢失 / 重复消费 / 顺序消费” 问题（必问）

这是分布式消息队列的**三大经典问题**，面试中需按 “生产者 + Broker + 消费者” 三个环节分析解决方案，以 Kafka 为例：

* **消息丢失**：生产者开启**ACK 确认**（确保消息发送到 Broker）、Broker 开启**副本持久化**（ISR 同步）、消费者关闭**自动提交 offset**（手动提交，确保消费成功后再提交）；
* **重复消费**：本质是**网络波动导致的重试 /offset 提交异常**，解决方案是**消费端实现幂等性**（如唯一 ID + 防重表、分布式锁、乐观锁）；
* **顺序消费**：Kafka 中**一个分区内的消息是有序的**，确保生产者按顺序发送、消费者单线程消费一个分区即可（牺牲吞吐量换顺序）。

## 三、分布式协调 / 锁（分布式核心基础，面试高频）

**核心定位**：解决分布式架构中**分布式锁、主从选举、分布式屏障、配置同步**等一致性问题，是分布式系统的 “协调器”。

**主流组件**：Zookeeper（ZK）、Redis/Redisson、etcd

**补充**：Curator 是 ZK 的 Java 客户端（封装了分布式锁、选举等功能），Redisson 是 Redis 的 Java 客户端（封装了分布式锁、集合等分布式功能），面试中常与核心组件一起考。

### 1. 核心组件参数表（面试核心记忆）


| 组件               | 核心定位         | 分布式锁实现方式                                  | CAP 选型          | 锁特性                                        | 性能           | 典型场景                               |
| ------------------ | ---------------- | ------------------------------------------------- | ----------------- | --------------------------------------------- | -------------- | -------------------------------------- |
| **ZK/Curator**     | 强一致分布式协调 | 临时有序节点 + Watcher                            | 纯 CP             | 可重入、阻塞、公平锁、**无锁丢失**            | 中（毫秒级）   | 数据一致性要求高的分布式锁、主从选举   |
| **Redis/Redisson** | 高性能分布式协调 | SET NX EX（原生）Redisson 封装（红锁 / 可重入锁） | 纯 AP（最终一致） | 可重入、非阻塞、公平锁 / 红锁、**可能锁丢失** | 极高（微秒级） | 高并发、一致性要求不高的分布式锁、限流 |
| etcd               | 云原生分布式协调 | 基于 Raft 的 CAS 操作 + 租约                      | 纯 CP             | 强一致、可重入、无锁丢失                      | 中             | K8s 集群协调、云原生分布式锁           |

### 2. 核心对比：ZK 分布式锁 vs Redis 分布式锁（面试必问）

这是分布式锁的**两大主流实现**，核心差异在**CAP 选型**，直接决定锁的特性和场景，面试中所有分布式锁选型问题都围绕这个核心展开：


| 维度       | ZK/Curator 分布式锁                                                                                  | Redis/Redisson 分布式锁                                                                                                  |
| ---------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| 核心原理   | 临时有序节点：创建节点成功则获锁，失败则监听前一个节点（阻塞），节点宕机则临时节点自动删除（释放锁） | SET NX EX：NX = 仅当节点不存在时创建，EX = 设置过期时间，避免宕机丢锁；Redisson 封装了红锁（多节点加锁）解决主从同步问题 |
| 锁丢失风险 | 无（临时节点随会话销毁，ZK 强一致）                                                                  | 有（主从异步同步，主节点宕机可能导致从节点无锁；过期时间设置不合理也会丢锁）                                             |
| 性能       | 中（毫秒级，需 ZK 集群交互）                                                                         | 极高（微秒级，内存操作）                                                                                                 |
| 锁特性     | 原生支持阻塞、公平锁、可重入                                                                         | 原生非阻塞，Redisson 封装后支持阻塞、公平锁、红锁、可重入                                                                |
| 运维成本   | 高（需部署 ZK 集群，维护 Leader 选举）                                                               | 低（Redis 已作为缓存部署，复用即可）                                                                                     |

#### 选型逻辑（面试应答框架）

* 选**ZK**：**数据一致性要求高、不追求极致性能**的场景，如订单库存扣减、分布式事务、主从选举（锁丢失会导致数据不一致）；
* 选**Redis**：**高并发、允许短暂锁失效**的场景，如秒杀限流、接口防刷、缓存更新（性能优先，短暂锁丢失无核心数据风险）；
* 选**etcd**：云原生 / K8s 生态下的分布式协调，替代 ZK。

### 3. 面试高频提问

* **问题 1**：Redis 分布式锁为什么会丢锁？怎么解决？
  **答**：丢锁原因有两个：① 主从异步同步，主节点宕机后从节点无锁；② 业务执行时间超过锁过期时间，锁被自动释放。
  解决方案：① 用 Redisson 的**红锁**（多 Redis 节点加锁，过半成功则获锁）；② 合理设置过期时间，或开启**锁续期**（Redisson 的 Watch Dog 机制，业务执行中定时刷新过期时间）；③ 消费端实现幂等性，即使丢锁也不会重复执行业务。
* **问题 2**：ZK 分布式锁的公平性怎么实现？
  **答**：基于**临时有序节点**，ZK 会为每个加锁请求生成一个有序的节点，请求者只会监听**前一个节点**，前一个节点释放锁后，当前请求者才会获锁，天然实现公平锁（按请求顺序加锁）。
* **问题 3**：为什么不用数据库做分布式锁？
  **答**：① 性能低（数据库行锁，磁盘操作，不适合高并发）；② 可靠性差（数据库宕机则锁不可用，需主从部署，同步复杂）；③ 功能弱（无原生的过期释放、阻塞锁，需二次开发）。

## 四、分布式存储（大数据 / 海量数据，面试中低频，重点了解核心）

**核心定位**：解决分布式架构中**海量数据存储、高可用、高扩展**问题，区别于单机数据库 / 文件系统。

**主流组件**：HDFS、Ceph、MinIO、TiDB

**分类**：分为**分布式文件存储**（存储文件 / 对象）和**分布式数据库**（存储结构化数据），面试中重点了解核心特性和场景。

### 1. 核心组件参数表


| 组件  | 类型               | 开源方     | 核心定位                 | 核心架构                      | 关键特性                         | 典型场景                         |
| ----- | ------------------ | ---------- | ------------------------ | ----------------------------- | -------------------------------- | -------------------------------- |
| HDFS  | 分布式文件存储     | Apache     | 大数据文件存储           | 主从架构（NameNode+DataNode） | 大容量、高吞吐、一次写入多次读取 | 大数据、日志存储、Hadoop 生态    |
| MinIO | 分布式对象存储     | MinIO 团队 | 轻量对象存储             | 分布式集群（纠删码）          | 轻量、高可用、兼容 S3 协议       | 图片 / 视频存储、云原生对象存储  |
| Ceph  | 分布式统一存储     | RedHat     | 块 / 文件 / 对象统一存储 | 无中心架构（Mon+OSD+MDS）     | 统一存储、高扩展、高可用         | 企业级海量存储、云平台存储       |
| TiDB  | 分布式关系型数据库 | PingCAP    | 分布式 NewSQL 数据库     | 计算 / 存储分离（TiDB+TiKV）  | 兼容 MySQL、水平扩展、强一致性   | 海量结构化数据、高并发 OLTP 场景 |

### 2. 面试高频考点

* TiDB 的核心优势：**兼容 MySQL + 水平扩展 + 强一致性**，解决了传统 MySQL 单机存储的瓶颈，适合电商、金融的海量结构化数据场景；
* MinIO 的核心优势：**轻量 + 兼容 S3 协议**，部署简单，适合中小企业的图片 / 视频等对象存储场景，替代阿里云 OSS / 腾讯云 COS；
* HDFS 的设计特点：**一次写入多次读取**，不适合随机写，适合大数据的日志采集、数据仓库场景。

## 五、分布式事务（分布式核心难点，面试高频）

**核心定位**：解决分布式架构中**跨服务 / 跨数据库的事务一致性**问题，遵循**BASE 理论**（最终一致性），因为分布式场景下无法实现单机事务的 ACID 强一致。

**主流方案 / 组件**：Seata、TCC、Saga、本地消息表、可靠消息最终一致性

**补充**：Seata 是阿里开源的分布式事务框架，封装了 TCC/SAGA/AT 等多种模式，是目前国内企业的主流选型。

### 1. 主流分布式事务方案对比（面试核心记忆）


| 方案                   | 实现方式                                     | 核心特性                     | 侵入性 | 适用场景                            | 典型组件                |
| ---------------------- | -------------------------------------------- | ---------------------------- | ------ | ----------------------------------- | ----------------------- |
| **Seata AT**           | 自动回滚 / 提交（基于本地事务 + 日志）       | 无业务侵入、自动化、最终一致 | 低     | 大部分分布式事务场景（国内主流）    | Seata                   |
| **TCC**                | 尝试（Try）- 确认（Confirm）- 取消（Cancel） | 强一致、高灵活               | 高     | 金融 / 电商核心场景（如支付、库存） | Seata TCC、自定义       |
| **Saga**               | 状态机 + 补偿操作                            | 低侵入、支持长事务           | 中     | 跨多服务的长事务（如订单流程）      | Seata SAGA、Camunda     |
| **本地消息表**         | 本地事务 + 消息队列                          | 无框架依赖、最终一致         | 中     | 中小系统、跨服务异步场景            | 自定义 + RocketMQ/Kafka |
| **可靠消息最终一致性** | 消息队列 + 事务消息                          | 无业务侵入、异步化           | 低     | 跨服务异步场景（如订单 - 物流）     | RocketMQ 事务消息       |

### 2. 面试高频考点（Seata 是重中之重）

#### （1）Seata AT 模式原理（必问，低侵入，国内主流）

基于**本地事务 + 全局事务协调**，无业务侵入，核心分两个阶段：

1. **第一阶段（本地事务）**：全局事务管理器向各分支事务节点发送指令，各节点执行本地事务，**不提交**，只记录**回滚日志**；
2. **第二阶段（全局提交 / 回滚）**：若所有分支事务执行成功，全局管理器发送提交指令，各节点提交本地事务并删除回滚日志；若有节点失败，发送回滚指令，各节点根据回滚日志回滚本地事务。

#### （2）TCC 模式原理（必问，高一致性）

基于**业务层的三段式设计**，需要开发者手动实现 Try/Confirm/Cancel 三个方法，侵入性高，但一致性最强：

1. **Try**：预留资源（如扣减库存前冻结库存）；
2. **Confirm**：确认执行（如冻结库存后实际扣减），仅当所有 Try 成功后执行；
3. **Cancel**：释放资源（如 Try 失败后解冻冻结的库存），若有一个 Try 失败则执行。

#### （3）分布式事务选型逻辑（面试应答框架）

* 优先选**Seata AT**：无业务侵入，开发效率高，适合 90% 的分布式事务场景；
* 核心金融场景（如支付、转账）选**TCC**：强一致性，牺牲开发效率换数据安全；
* 跨多服务的长事务（如订单创建→支付→物流→发货）选**Saga**：支持状态机，适合流程化的长事务；
* 无框架依赖、中小系统选**本地消息表 / 可靠消息最终一致性**：基于消息队列，实现简单，适配异步场景。

## 六、分布式组件通用面试提问 & 应答技巧

### 1. 通用问题（跨品类，必问）

* **问题 1**：谈谈你对 CAP 理论和 BASE 理论的理解，分布式组件的设计如何体现？
  **答**：① CAP：分布式系统中，一致性（C）、可用性（A）、分区容错性（P）三者不可兼得，必须取舍，**所有分布式组件都在 CP/AP 之间做选择**（如 ZK 是 CP，Eureka 是 AP）；② BASE：是 CAP 的延伸，意为**基本可用、软状态、最终一致**，是分布式系统的实际设计准则（如消息队列的最终一致、微服务的最终一致）。
* **问题 2**：分布式组件的高可用怎么实现？
  **答**：核心手段有三个：① **集群部署**（主从 / 副本 / 分区）；② **故障自动切换**（Leader 选举、哨兵模式）；③ **数据持久化 / 副本同步**（如 Kafka 的 ISR、Redis 的主从复制）。
* **问题 3**：如何设计一个高可用的分布式架构？（综合题）
  **答**：从组件选型入手，按 “分层设计” 梳理：① 服务层：Nacos（AP）做注册 / 配置，保证服务发现高可用；② 通信层：RocketMQ/Kafka 做消息队列，解耦 + 削峰；③ 协调层：Redis 做高性能分布式锁，ZK 做核心一致性协调；④ 存储层：TiDB 做分布式数据库，MinIO 做对象存储；⑤ 事务层：Seata AT 做分布式事务，保证最终一致；⑥ 整体：所有组件集群部署，做故障监控和自动扩容。

### 2. 应答技巧（面试提分）

1. **所有区别 / 选型问题，先定 CAP/BASE**：这是分布式组件的设计核心，先点明 CP/AP 选择，再讲特性 / 场景，逻辑更清晰；
2. **结合实际项目**：面试中不要只背理论，要结合自己的项目经验，比如 “我在项目中用 Nacos 做注册中心，因为基于 Spring Cloud Alibaba，且需要动态配置热更新，替代了原来的 Eureka+ZK”；
3. **抓核心，弃细节**：面试中不需要背组件的所有配置，只需记住**核心定位、协议、CAP、关键特性、典型场景**，比如 Kafka 只需记住 “高吞吐、磁盘顺序写、ISR、大数据生态”。

## 七、分布式组件生态关联图（面试快速梳理）

为了方便记忆，用一句话梳理各组件的关联，贴合实际项目架构：

**基于 Spring Cloud Alibaba 的微服务架构中，用 Nacos 做一站式注册 / 配置中心，用 RocketMQ 做消息队列解耦 / 削峰，用 Redis 做缓存 + 高性能分布式锁，用 ZK 做核心一致性协调（如主从选举），用 Seata AT 做分布式事务，用 TiDB 做海量结构化数据存储，用 MinIO 做图片 / 视频存储**。

这套架构是目前**国内企业的主流分布式架构**，覆盖了大部分面试中的组件场景，记住这个关联，应对综合题会更轻松。
