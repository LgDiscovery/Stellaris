### 详细介绍了Seata分布式事务框架的四种核心模式

AT模式是默认且最常用的模式，开发成本最低，只需添加注解即可。

原理为两阶段提交：第一阶段各分支执行[SQL]()并提交，同步记录undo log（数据修改前的快照）；

第二阶段若全部成功则删除undo log，若有失败则用undo log自动回滚。回滚时会上毫秒级行锁防止数据篡改，性能影响小，覆盖约90%的常规业务场景。 TCC模式需手动实现三阶段逻辑：Try阶段检查并预留资源（如冻结库存），[Confirm]()阶段执行真正操作（如扣减库存），[Cancel]()阶段释放资源（如返还冻结库存）。相比AT无锁性能更高，但需自行编码实现三个阶段，适合对性能和定制化有要求的场景。 Saga模式用于处理长业务流程（非长事务），将流程拆分为多个短事务，出错时进行反向补偿（如运输出问题则依次取消派送、退回运输、退款）。这是业务流程层面的[ACID]()保障，可视为状态机，适用于需要业务级容错的长流程场景。 XA模式提供严格的强一致性，同样是两阶段：准备阶段执行SQL但不提交，提交阶段统一通知提交或回滚。由于数据库事务隔离级别会导致数据阻塞，严重影响并发能力，仅适用于一致性要求极高、并发量不高的核心金融业务（如银行转账）。 总结口诀：零侵入高并发选AT，要性能定制选TCC，长流程容错选Saga，强一致低并发选XA。

# 分布式事务 面试高频问题 + 标准答案（直接背）

### 问题 1：请说说 **2PC 的核心流程、缺点，以及为什么会出现数据不一致？**

**标准答案**

1. 核心流程：分**准备阶段**和**提交阶段**，由协调者主导，参与者执行。
   * 准备阶段：协调者发 “准备指令”，参与者执行本地事务（不提交），锁定资源，返回 “同意提交 / 中止”。
   * 提交阶段：协调者收到**所有参与者同意**，则发 “提交指令”；否则发 “回滚指令”。
2. 核心缺点：**同步阻塞**（参与者全程锁资源，性能差）、**单点故障**（协调者宕机，事务卡死）、**数据不一致风险**。
3. 数据不一致场景：提交阶段，协调者发出提交指令后宕机 → 部分参与者收到指令提交，部分没收到，导致节点数据不一致。

### 问题 2：**2PC 和 TCC 的核心区别是什么？分别适用于什么场景？**

**标准答案**


| 对比维度   | 2PC                                  | TCC                                            |
| ---------- | ------------------------------------ | ---------------------------------------------- |
| 一致性     | 强一致性                             | 最终一致性                                     |
| 资源锁定   | 全程锁资源（同步阻塞）               | 仅 Try 阶段预留资源，无阻塞                    |
| 业务侵入性 | 无侵入（数据库层面实现）             | 强侵入（业务需写 Try/Confirm/Cancel 3 套逻辑） |
| 性能       | 低                                   | 高                                             |
| 适用场景   | 低并发、强一致场景（如金融核心转账） | 高并发微服务场景（如电商下单、秒杀）           |

### 问题 3：**SAGA 模式的核心原理是什么？如何处理失败的补偿逻辑？**

**标准答案**

1. 核心原理：把分布式长事务拆成**多个独立的本地事务**，每个本地事务对应一个**补偿事务**（反向操作）。
   * 正向流程：按顺序执行 `T1→T2→T3` 所有本地事务。
   * 补偿流程：若某一步失败（比如 T2 失败），则反向执行补偿事务 `C1→C2`，撤销已完成的操作。
2. 补偿逻辑处理原则：
   * 补偿事务必须是**幂等的**（重复执行结果一致）。
   * 补偿逻辑要考虑**业务回滚的完整性**（比如订单生成失败要删订单，库存扣减失败要恢复库存）。
   * 支持**手动补偿**：极端情况（如补偿失败）需人工介入。

### 问题 4：**本地消息表方案的核心流程是什么？如何保证消息不丢不重？**

**标准答案**

1. 核心流程（三步保证消息可靠）：
   * ① 本地事务：执行业务操作（如扣余额） + **写消息到本地消息表**（同个本地事务，要么都成功，要么都失败）。
   * ② 消息投递：定时任务扫描本地消息表，把未发送的消息投递到 MQ。
   * ③ 消息消费：下游服务消费消息，执行业务（如加积分），消费成功后通知上游更新消息状态为 “已完成”。
2. 不丢不重的保证：
   * 不丢：本地事务绑定消息写入 + 定时任务重试投递。
   * 不重：消费端实现**幂等性**（比如用消息 ID 做唯一键，重复消费直接过滤）。

### 问题 5：**分布式事务中，为什么要保证幂等性？怎么实现幂等性？**

**标准答案**

1. 必要性：分布式环境下网络不可靠，会出现**消息重复投递**（如 MQ 重试）、**接口重复调用**（如超时重试），如果没有幂等性，会导致数据错误（比如重复扣钱、重复加积分）。
2. 实现方案（3 种常用）：
   * ① **唯一键防重**：比如用订单 ID、消息 ID 作为数据库唯一键，重复请求插入时直接报错。
   * ② **状态机控制**：比如订单状态从 “待支付”→“已支付”，重复支付请求判断状态后直接拒绝。
   * ③ **令牌机制**：请求前先获取令牌，执行操作时校验令牌有效性，执行完销毁令牌。

### 问题 6：**CAP 定理和 BASE 理论，和分布式事务有什么关系？**

**标准答案**

1. CAP 定理：分布式系统无法同时满足一致性（C）、可用性（A）、分区容错性（P），必须三选二。分布式事务的方案本质是 **CAP 的取舍**。
   * 选 CP（一致性 + 分区容错）：对应强一致方案（如 2PC），牺牲可用性（同步阻塞）。
   * 选 AP（可用性 + 分区容错）：对应最终一致方案（如 TCC/SAGA），牺牲强一致性。
2. BASE 理论：是 CAP 定理的妥协方案，核心是**基本可用、软状态、最终一致性**，这是绝大多数互联网分布式事务方案的设计指导思想（比如电商场景，允许短暂的库存不一致，最终保证一致即可）。

### 问题 7：**你在项目中用过哪种分布式事务方案？怎么落地的？**

**标准答案（万能模板，按需替换）**

> 我们在电商订单系统中用了 **TCC 模式**。
>
> 1. 业务场景：下单流程涉及「扣库存（库存服务）+ 扣余额（支付服务）+ 生成订单（订单服务）」。
> 2. 落地步骤：
>    * Try 阶段：库存服务冻结商品库存，支付服务冻结用户余额，订单服务生成待支付订单。
>    * Confirm 阶段：用户支付成功后，依次扣减冻结库存、扣减冻结余额、更新订单为已支付。
>    * Cancel 阶段：用户超时未支付，依次释放冻结库存、释放冻结余额、删除待支付订单。
> 3. 关键保障：所有接口实现幂等性，用 Redis 分布式锁防止并发问题，用日志记录每一步状态，方便问题排查。
>
