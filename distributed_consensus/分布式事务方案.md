# 5 种分布式事务方案原理 通俗讲解（面试版）

用**生活化例子**讲透核心逻辑，拒绝专业术语堆砌，好记又好懂

## 1. 两阶段提交（2PC）

### 通俗原理

把分布式事务比作 **「公司团建订餐」**

* **角色**：协调者 = 行政小姐姐；参与者 = 各个部门
* **阶段 1：准备阶段**
  行政挨个问部门：“周五团建吃火锅，你们部门能去不？”
  每个部门确认后回复 “能去”，行政就让火锅店**预留好座位**（对应：参与者执行本地操作，锁定资源，不最终提交）。
* **阶段 2：提交阶段**
  只有**所有部门都回复能去**，行政才会给火锅店说 “确定下单”（对应：协调者发提交指令，参与者最终提交事务）；
  只要有一个部门说 “去不了”，行政就会取消预订（对应：协调者发回滚指令，参与者释放资源）。

### 核心特点

* 强一致性，像 “必须所有人同意才能定”，简单直接
* 缺点也很明显：占着座位等所有人回复（**同步阻塞**）；行政小姐姐请假了就没人管了（**单点故障**）

## 2. 三阶段提交（3PC）

### 通俗原理

是 2PC 的 “升级版团建订餐”，解决 2PC 的**卡死问题**

* 新增 **「预检查阶段」** + **「超时机制」**
  行政先问部门：“周五有空不？”（预检查，不用锁定火锅店座位），确认大部分人有空，再进入准备阶段（让火锅店留座）；
  就算行政小姐姐中途失联，超过时间，部门会自动默认 “活动取消”，不会一直占着座位（对应：超时自动终止，避免资源长期锁定）。

### 核心特点

* 比 2PC 灵活，减少阻塞，但流程变复杂了
* 本质还是 “强一致” 思路，极端情况还是可能数据不一致

## 3. TCC（Try-Confirm-Cancel）

### 通俗原理

把分布式事务比作 **「网购下单付款」**

* **角色**：Try = 下单；Confirm = 付款；Cancel = 取消订单
* **Try 阶段：预留资源**
  你选好商品下单，系统会**冻结库存**（别人买不了）+ **冻结你的账户余额**（钱不会直接扣），只占住资源，不完成交易。
* **Confirm 阶段：确认提交**
  你付款成功后，系统才会**真正扣减库存** + **扣减余额**，完成交易（只有所有服务的 Try 都成功，才执行 Confirm）。
* **Cancel 阶段：取消回滚**
  你取消订单，系统会**释放冻结的库存** + **解冻余额**，恢复到下单前的状态（只要有一个服务 Try 失败，就执行 Cancel）。

### 核心特点

* 全程不阻塞，性能高，像 “先占坑再付款”
* 缺点：需要业务代码写 3 套逻辑（Try/Confirm/Cancel），开发麻烦

## 4. SAGA 模式

### 通俗原理

把分布式事务比作 **「旅游报团流程」**

* 整个旅游流程拆成多个**独立小步骤**（本地事务）：报名 → 付定金 → 订机票 → 订酒店
* 每个步骤都对应一个**反向补偿步骤**：
  * 订酒店失败 → 退机票 → 退定金 → 取消报名
  * 订机票失败 → 退定金 → 取消报名
* 执行逻辑：**按顺序执行正向步骤**，哪一步失败，就**从哪一步往回执行补偿步骤**

### 核心特点

* 不用锁资源，像 “一步错，回头改”，适合长流程业务
* 缺点：中间状态可能不一致（比如机票订好了，酒店没订好，会有短暂的 “机票已订” 状态），最终才会一致

## 5. 本地消息表（可靠消息队列）

### 通俗原理

把分布式事务比作 **「外卖点餐送餐」**

* **商家操作（本地事务）**：你下单后，商家同时做两件事（在一个本地事务里）
  1. 生成订单（执行业务操作）；
  2. 写一张纸条（本地消息表）：“给 XX 小区送一份麻辣烫”。
     → 这两件事要么都成功，要么都失败，保证消息不会丢。
* **骑手送餐（消息投递）**：商家定时看纸条，把纸条交给骑手（定时任务扫描消息表，发消息到 MQ）；如果骑手没送到，就再派一个骑手（重试机制）。
* **你收餐（消息消费）**：你收到麻辣烫，告诉商家 “收到了”（下游服务消费消息，执行业务）；商家划掉纸条（更新消息状态为 “已完成”）。

### 核心特点

* 不用改核心业务代码，像 “留纸条备忘”，简单易落地
* 缺点：有延迟（下单到送餐有时间差），是最终一致性
